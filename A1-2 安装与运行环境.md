## 第二章 安装与运行环境

参考博客：[Go 入门指南](https://learnku.com/docs/the-way-to-go/book-intro/3560)

《Go 入门指南》是 《The Way to Go》的中文译本，本书专为 Golang 初学者量身定制。

### 2.1 平台与架构

Go 语言开发团队开发了适用于以下操作系统的编译器：

- Linux
- FreeBSD
- Mac OS X（也称为 Darwin）

目前有 2 个版本的编译器：Go 原生编译器 gc 和非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。其中，gc 版本的编译器已经被移植到 Windows 平台上，并集成在主要发行版中，你也可以通过安装 MinGW 从而在 Windows 平台下使用 gcc 编译器。这两个编译器都是以单通道的形式工作。

你可以获取以下平台上的 Go 1.4 源码和二进制文件：

+ Linux 2.6+：amd64、386 和 arm 架构
+ Mac OS X（Snow Leopard + Lion）：amd64、386 和 arm 架构
+ Windows 2000+：amd64 和 386 架构

对于非常底层的纯 Go 语言代码或者包而言，在各个操作系统平台上的可移植性是非常强的，只需要将源码拷贝到相应平台上进行编译即可，或者可以使用交叉编译来构建目标平台的应用程序（第 2.2 节）。

但如果你打算使用 cgo 或者类似文件监控系统的软件，就需要根据实际情况进行相应地修改了。

#### 2.1.1 Go 原生编译器 gc

主要基于 Ken Thompson 先前在 Plan 9 操作系统上使用的 C 工具链。

Go 语言的编译器和链接器都是使用 C 语言编写并产生本地代码，Go 不存在自我引导之类的功能。因此如果使用一个有不同指令集的编译器来构建 Go 程序，就需要针对操作系统和处理器架构（32 位操作系统或 64 位操作系统）进行区别对待。

这款编译器使用非分代、无压缩和并行的方式进行编译，它的编译速度要比 gccgo 更快，产生更好的本地代码，但编译后的程序不能够使用 gcc 进行链接。

#### 2.1.2 gccgo 编译器

一款相对于 gc 而言更加传统的编译器，使用 GCC 作为后端。GCC 是一款非常流行的 GNU 编译器，它能够构建基于众多处理器架构的应用程序。编译速度相对 gc 较慢，但产生的本地代码运行要稍微快一点。它同时也提供一些与 C 语言之间的互操作性。

从 Go 1 版本开始，gc 和 gccgo 在编译方面有了等价的功能。

#### 2.1.3 文件扩展名与包(package)

Go 语言源文件的扩展名很显然就是 .go。

C 文件使用后缀名 .c，汇编文件使用后缀名 .s。所有的源代码文件都是通过包（packages）来组织。包含可执行代码的包文件在被压缩后使用扩展名 .a（AR 文档）。

Go 语言的标准库（第 9.1 节）包文件在被安装后就是使用这种格式的文件。

注意 当你在创建目录时，文件夹名称永远不应该包含空格，而应该使用下划线 “_” 或者其它一般符号代替。



### 2.2 Go 环境变量

Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：

+ **$GOROOT** 表示 Go 在你的电脑上的安装位置，它的值一般都是 `$HOME/go`，当然，你也可以安装在别的地方。
+ **$GOARCH** 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。

+ **$GOOS** 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。

- **$GOBIN** 表示编译器和链接器的安装位置，默认是 `$GOROOT/bin`，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。

目标机器是指你打算运行你的 Go 应用程序的机器。

Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。

**OS: 不过上面这个特性感觉JAVA也有哈哈哈**

为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显式设置，他们的值会和目标机器（$GOOS 和 $GOARCH）一样。

+ $GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。
+ **$GOARM** 专门针对基于 arm 架构的处理器，它的值可以是 5~7，默认为 6。
  + GOARM=5: 使用软件浮点（software floating point）；当 CPU 没有 VFP 协同处理器时
  + GOARM=6: 仅使用 VFPv1; 使用交叉编译时的默认使用此选项，通常在 ARM11 或更高版本的内核中使用（也支持 VFPv2 或更高版本）
  + GOARM=7: 使用 VFPv3；通常在 Cortex-A 内核中使用

- **$GOMAXPROCS** 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节



### 2.3 Go安装目录清单

Go 安装目录（`$GOROOT`）的文件夹结构应该如下所示：

README.md, AUTHORS, CONTRIBUTORS, LICENSE

+ /bin：包含可执行文件，如：编译器，Go 工具
+ /doc：包含示例程序，代码工具，本地文档等
+ /lib：包含文档模版
+ /misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例
+ /os_arch：包含标准库的包的对象文件（.a）
+ /src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言）
+ /src/cmd：包含 Go 和 C 的编译器和命令行脚本



### 2.4 Go 运行时 - Runtime

#### 2.4.1 Runtime

尽管 Go 编译器产生的是本地可执行代码，然而这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。

这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 11.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。

runtime 主要由 C 语言编写（自 Go 1.5 起开始自举），并且是每个 Go 包的最顶级包。你可以在目录 [`$GOROOT/src/runtime`](https://github.com/golang/go/tree/master/src/runtime) 中找到相关内容。

#### 2.4.2 垃圾回收器

Go 拥有简单却高效的标记 - 清除回收器。

+ 它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。

+ 目前 gccgo 还没有回收器，同时适用于 gc 和 gccgo 的新回收器正在研发中。
+ 使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，即分配和回收内容都是消耗 CPU 资源的一种行为。

#### 2.4.3 Runtime 嵌入

Go 的可执行文件都比相对应的源代码文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。当然，在部署到数量巨大的集群时，较大的文件体积也是比较头疼的问题。

但总得来说，Go 的部署工作还是要比 Java 和 Python 轻松得多。因为 Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样被各种不同版本的依赖文件混淆。



### 2.5 Go 解释器

因为 Go 具有像动态语言那样快速编译的能力，自然而然地就有人会问 Go 语言能否在 REPL（read-eval-print loop）编程环境下实现。

Sebastien Binet 已经使用这种环境实现了一个 Go 解释器，你可以在这个页面找到：[github.com/sbinet/igo](https://github.com/sbinet/igo)。

这段话提到了几个关键点，让我们逐一解释：

+ **Go语言的快速编译能力**： Go语言以其快速的编译速度而闻名，这使得它在某些方面类似于动态语言。动态语言（如Python、Ruby等）通常在运行时解释执行，不需要编译步骤，因此可以快速迭代和测试代码。Go语言虽然需要编译，但它的编译速度非常快，这使得开发过程可以更加迅速和灵活。
+ **REPL编程环境**： REPL是“Read-Eval-Print Loop”的缩写，它是一种编程环境，允许程序员输入代码，然后立即看到结果。这种环境对于快速测试和探索代码非常有用，因为它提供了即时的反馈。许多动态语言都有自己的REPL环境，如Python的交互式解释器。
+ **Sebastien Binet实现的Go解释器**： Sebastien Binet是一个开发者，他创建了一个Go语言的解释器。这意味着他开发了一个工具，可以在没有编译整个程序的情况下，直接执行Go代码。这使得Go语言可以在REPL环境中使用，从而提供了类似于动态语言的编程体验。
+ **igo项目**： igo是Sebastien Binet开发的Go解释器项目，它允许用户在REPL环境中运行Go代码。这个项目可以在GitHub上找到，通过提供的链接可以访问项目的页面，查看文档、源代码以及如何使用这个工具。

这段话的意思是，尽管Go语言是一种静态类型的编译语言，但由于其快速的编译能力，有人（Sebastien Binet）已经实现了一个Go语言的解释器，使得Go代码可以在REPL环境中运行，从而提供了一种更加动态和交互式的编程体验。